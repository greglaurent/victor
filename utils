#!/usr/bin/env bash

HERE=$(cd $(dirname "${BASH_SOURCE[0]}") &>/dev/null && pwd)

DIR=""
CMD=""
ARG=""

declare -A dirs

utils::bootstrap() {
  unset DIR
  unset CMD
  unset ARG

  mkdir -p "${HERE}/repos" >&2

  utils::path::map_dirs

  #utils::path::print_lookup
}

utils::parse_args() {
  while (("$#")); do
    [[ -z $DIR ]] && DIR="${1}" && shift && continue
    [[ -z $CMD ]] && CMD="${1}" && shift && continue
    [[ -z $ARG ]] && ARG="${1}" && shift && continue
  done
}

utils::exec() {
  local here="${HERE}"
  local -n ref_dirs="dirs"

  utils::parse_args "$@"
  local -n ref_dir="DIR"
  local -n ref_cmd="CMD"
  local -n ref_arg="ARG"

  echo "ref_dir: ${ref_dir}"
  echo "ref_cmd: ${ref_cmd}"
  echo "ref_arg: ${ref_arg}"

  # shift variables
  # if passed as -> dir cmd arg, instead of -> dir:cmd arg
  [[ ! -z "${ref_arg}" ]] && ref_dir="${DIR}:${CMD}" && ref_cmd="${ARG}"

  local path="${dirs["${ref_dir}", "${ref_cmd}"]}"

  echo "path: ${path}"
  "${path}" >&1
}

utils::path::map_dirs() {
  local here="${HERE}"
  local -a out_d
  local -a out_f

  # skip hidden directories
  mapfile -t out_d < <(find "${here}" -maxdepth 2 -mindepth 1 -not -path '*/.*' -type d -printf '%P\n')

  for d in "${out_d[@]}"; do
    local path="${here}/${d}"
    mapfile -t out_f < <(find "${path}" -maxdepth 1 -mindepth 1 -executable -type f)

    local key_1=$(echo "${d}" | sed -r 's/\//:/g')
    for f in "${out_f[@]}"; do
      local key_2=$(basename "${f}")
      dirs["${key_1}", "${key_2}"]="${f}"
    done
  done
}

utils::path::print_lookup() {
  local -n ref="dirs"
  for d in "${!ref[@]}"; do
    printf 'KEY: %s' "${d}" >&2
    printf "\n" >&2
    printf 'VALUE: %s' "${ref["${d}"]}" >&2
    printf "\n" >&2
  done
}
